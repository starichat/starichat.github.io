---
title: vim 使用教程
date: 2019-04-11 12:14:04
tags: 测试
---

最近数据泄露似乎出现的比较频繁，这半年以来已经有华住，陌陌，Quora，12306 …..出现数据泄露。当然，现在大多数网站存储的密码也不再会是明文形式了。今天，我们借密码泄露事件谈一谈怎样才能安全地保存用户密码这么重要的数据呢？

首先，要知道如何保存用户密码，我们必须先要明白哈希算法。
什么是哈希算法：
我们知道散列表，散列函数吧？不知道没关系，我下文会介绍，可以暂时做个简单了解。

哈希算法的定义就是将任意长度的二进制值串映射为固定长度的二进制值串，这个映射的规则就是哈希算法，而通过原始数据映射之后得到的二进制值串就是哈希值。

一个好的哈希算法需要满足以下几个条件：

从哈希值不能反向推导出原始数据
对输入数据敏感，那怕原始数据只修改了一个bit，最后得到的哈希值也大不相同。
散列冲突的概率要很小，对于不同的原始数据，哈希值相同的概率非常小
哈希算法的执行效率要尽量高，针对较长的文本，也能快速地计算出哈希值。
业界著名的哈希算法有诸如 MD5,SHA，DES, AES 等优秀的算法。但仍然不能算作很完美。
先来看看MD5算法吧

MD5 加密实例
先看一种 md5 加密的实现代码：

 
public static String md5(String plainText) {
    //定义一个字节数组
    byte[] secretBytes = null;
    try {
        // 生成一个MD5加密计算摘要
        MessageDigest md = MessageDigest.getInstance("MD5");
        //对字符串进行加密
        md.update(plainText.getBytes());
        //获得加密后的数据
        secretBytes = md.digest();
    } catch (NoSuchAlgorithmException e) {
        throw new RuntimeException("没有md5这个算法！");
    }
    //将加密后的数据转换为16进制数字
    String md5code = new BigInteger(1, secretBytes).toString(16);// 16进制数字
    // 如果生成数字未满32位，需要前面补0
    for (int i = 0; i < 32 - md5code.length(); i++) {
        md5code = "0" + md5code;
    }
    return md5code;
}
通过以上 MD5 算法加密后，我们发现加密后的密文有两个很突出的特点：

无论要哈希的文本有多长或者多短，通过哈希后的值的长度都是相同的。

md5("asdfaf545413adafakfljsfa")  7404686fc7bff68dc560021f9bc08329
md5("好")                        ac2c8f13c6e60810197b19d683f5f184
改变一个字符就会有很大的差别

md5("asdfaf545413adafakfljsfa")  7404686fc7bff68dc560021f9bc08329
md5("asdfaf645413adafakfljsfa")  9fc80292ab77a83f8d68e5eb708a73b3
我只将其中一个数字 5 变成了数字 6 ，但是密文变化特别大。

字典攻击
但是通过这段实例，我们也发现了虽然哈希算法是不可逆的，但如果数据被脱裤，虽然拿到的是加密后的密文，但可以通过猜的方式来破解密码，这是因为，有些用户的密码太简单。比如很多人习惯用
000000 123456 这样的简单数字组合做密码，就很容易被猜中。 关于字典攻击，这里有一篇关于彩虹表的文章可以帮助我们理解字典攻击什么是彩虹表

针对字典攻击，我们引入一个salt，跟用户的密码组合在一起，增加密码的复杂度，同时即使破解之后也无法拿到所有用户的数据。我们拿组合之后的字符串来说，
将它存储到数据库中，进一步增加破解的难度。不过我这里想多说一句，我认为安全和攻击是一种博弈关系，不存在绝对的安全。所有的安全措施，就是增加攻击的成本而已。

基于哈希算法的 4 个特点，我们有很多应用，例如：

应用：安全加密
最常用于安全加密的哈希算法是：MD5,SHA,除此之外还有很多加密算法，如DES,AES
对于加密算法有两点非常重要

1.很难根据哈希值反向推导出原始数据，
2.散列冲突的概率要很小。
第一点就是要保证加密后原始数据的泄露而导致数据被反向推导出来。不管什么哈希算法，都无法做到绝对的 0 冲突，我们只能做到减少冲突。

在组合数学中有这样一个理论，鸽笼原理，如果有 10 个鸽笼，但是有 11 只鸽子，必然会有至少有两只鸽子在一个鸽笼里。

我们知道，哈希算法产生的哈希值的长度是固定且有限的。比如前面举的 MD5 的例子，哈希值是固定的 128 位二进制串，能表示的数据非常有限，最多只能表示 2^128 个数据，但是现实情况是数据非常多。

不过，即便哈希算法存在散列冲突的情况，但是因为哈希值的范围很大，冲突的概率极低，所以相对来说还是很难破解。如 MD5 2^128 这已经是一个天文数字了。
如果拿到一个MD5哈希值，希望通过穷举的方法来找出答案，那耗费的时间也是一个天文数字。
在平时开发中，我们也需要权衡选择算法的利弊，虽然有更高的加密算法，但是时间效率也会降低。所以，我们在实际开发中也需要不同的需求选择不同的哈希算法。

应用：唯一标识
如果要在海量的图库中，搜索一张图是否存在，我们不能单纯地用图片的元信息来比对，因为有可能存在名称相同但图片内容不同，或者名称不同图片相同的情况。那又该如何搜索呢？

任何文件在计算机中都可以表示成二进制码串，所以，比较笨的办法就是，拿要查找的图片的二进制码串与图库中所有图片的二进制码串进行比对。如果相同，则说明图片存在，但是这种比对方法太耗时了。

所以，我们可以给每一个图片取一个唯一标识，或者说信息摘要。比如，我们可以从图片的二进制码串开头取 100 个字节，从中间取100个字节，从最后再取100个字节，然后将这300个字节放在一块，通过哈希算法得到一个哈希字符串，用它作为图片的唯一标识。通过这个唯一标识来判定图片是否在图库中，这样可以减少很多工作量。

如果不存在，那就说明这个图片不在图库中，如果存在，我们再通过散列表中存储的文件路径，获取到这个已经存在的图片，跟现在要插入的图片做全量的比对，看是否完全一样。如果一样，就说明已经存在，如果不一样，说明两张图片尽管唯一标识相同，但是并不是相同的图片。

应用：数据校验
目前很多软件都是基于 p2p 协议下载，就是我们可以从多个机器并行下载一个文件，这个文件可能被分割成很多文件块。等所有文件块都下载
完成后，在组装成一个完整的电影文件。但是我们知道，网络传输是不安全的，下载的文件块很有可能被宿主机器恶意修改过，又或者下载过程汇总出现了错误，所以下载的文件块很有可能是不完整的。如果我们没有能力检测这种恶意修改或者文件下载出错，就会导致最终合并后的电影无法观看，甚至导致电脑中毒。现在的问题是怎样校验。

我们通过哈希算法，对100个文件块分别取哈希值，并且保存在种子文件中。我们在前面讲过，哈希算法有一个特点，对数据很敏感。只要文件块的内容有一丁点的改变，最后计算出的哈希值就会完全不同。所以，当文件下载完成之后，我们可以通过相同的哈希算法，对下载好的文件块逐一求哈希值，然后跟种子文件中保存的
哈希值进行比对。如果不同，则说明被篡改了。



字符串匹配算法，在工程中用得很多，我们用到的最多的数据类型恐怕就是字符串了。我们用到的很多函数，诸如 indexOf（），lastIndexOf() 等，他们的底层就需要依赖字符串匹配算法了。

字符串匹配算法很多，先来看看较为简单，易理解的算法吧，他们分别是 BF 算法和 RK 算法。

BF 算法
BF 算法就是暴力破解的意思。先定义两个概念：主串和模式串。字符串匹配就是在主串中匹配模式串。
下面来看看 BF 算法定义：
在主串中，检查起始位置分别是 0，1，2….n-m 且长度为 m 的 n-m + 1 个子串，看有没有跟模式串匹配的。如下图：
从 第一个字符开始和主串匹配，每次没有匹配成功，则向后移动一位，再一次执行主串和模式串的匹配，直到匹配成功或者没有找到匹配的字符串。

[![kscgOO.md.jpg](https://s2.ax1x.com/2019/02/16/kscgOO.md.jpg)](https://imgchr.com/i/kscgOO)

我们可以发现这个算法的复杂度很高，是O（n*m）,但是在实际的开发中，用的还挺多的，理由如下：

实际的软件开发，大部分情况下，模式串和主串的长度都不会太长。而且每次模式串与主串的子串匹配的时候，当中途遇到不能匹配的字符的时候，就可以停止了，不需要把 m 个字符都比对一下。所以，尽管理论上的最坏情况时间复杂度是 O（n*m）,但是统计意义上大部分情况下，算法执行效率要比这个高得多。
BK 算法思想简单，代码实现也非常简单。简单意味着不容易出错，如果有 bug 也容易暴露和修复。
RK 算法：
在 BK 算法中，我们每一次匹配都需要将模式串的每一个字符和主串进行比较，所以时间复杂度比较高 O（m*n),所以 RK 算法在此基础上进行了优化。

思路是这样的，通过哈希算法对主串的 n-m+1 个子串分别求哈希值，然后逐个与模式串的哈希值比较大小。如果某个子串的哈希值与模式串相等，那就说明对应的子串和模式串匹配了。因为哈希值是一个数字，数字之间比较是非常快速的。。所以比较效率就提升了。即不需要通过将每一个模式串和每一个需要匹配的主串进行字符匹配，只用匹配其哈希值就可以了。

但是，我们仍然需要遍历子串中的每个字符，所以我们设计了一个合适的哈希算法来处理这个遍历。

我们假设要匹配的字符串的字符集中只包含K个字符，我们可以用一个K进制数来表示一个子串，这个K进制数转化为十进制数，作为子串的哈希值表述起来有点抽象。

例如：我们要处理a~z这26个小写字母，那我们就用二十六进制表示一个字符串，我们把a~z这个26个字符映射到0~25这26个数字，a就表示0，b 就表示 1.。。。。。。

[![kscEWt.md.jpg](https://s2.ax1x.com/2019/02/16/kscEWt.md.jpg)](https://imgchr.com/i/kscEWt)

将字符串对应成一个26进制的数，这样将这个26进制的值转换为10进制的数，这个数就是我们所需要的哈希值。

相邻两个子串对应的哈希值计算公式有交集，也就是说，我们可以使用的哈希值s[i-1]很快的计算出s[i]的哈希值，根据设计，我们可以发现RK 可以实现只扫描一遍主串就能计算出所有的子串的哈希值了，所以这部分的时间复杂度是O（n)

[![kscZSP.md.jpg](https://s2.ax1x.com/2019/02/16/kscZSP.md.jpg)](https://imgchr.com/i/kscZSP)

模式串哈希值域每个子串哈希值之间的比较的时间复杂度是O（n）。所以 RK 算法整体的时间复杂度就是O（n)

